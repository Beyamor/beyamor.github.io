<html><head><meta charset="utf-8" /><title>And The Template Of Doom</title><link href="/css/shades-of-purple.min.css" rel="stylesheet" /><link href="/css/common.css" rel="stylesheet" /><link href="/css/blog.css" rel="stylesheet" /><script src="/js/highlight.min.js" type="text/javascript"></script></head><body><div id="header"><h1><a href="/">Words in the Sky</a></h1><a href="/blog">Blog</a></div><div id="content"><div id="blog"><h1 class="title">And The Template Of Doom</h1><h2 class="date">Sep 19, 2011</h2><div id="content"><html><head></head><body><p>I'm absolutely elated right now. Elated, and terrified.</p><p>I was sitting down to write a simple rendering component when I ran into a stumbling block. Or, well, a musing block. A problem, sure, but a chance to think. Like we established, now and again one component is going to need to reference another. In this case, the <em>Renderer</em> needed to know about the <em>Spatial</em>. No sweat, right? I'd already done the same for the <em>PlayerIntent</em> component. I cracked that guy open to see how I'd done it and was met with some grossness.</p><pre><code>shared_ptr&lt;Component&gt; sharedNeighbour = neighbour.lock();
Component* rawNeighbour = sharedNeighbour.get();
Spatial* spatial = dynamic_cast&lt;Spatial*&gt;( rawNeighbour );
if ( spatial )
	this-&gt;spatial = spatial;</code></pre><p>Okay, it looks nasty, but is it really so bad? Just a quick copy-paste and I'm on my way. I mean, if I need to change the type of referenced component, I just need to tweak this a little, so that's no big deal. And if I decide I want to change how the underlying reference works? Some better handling of that raw pointer there? I just need to change, uh, every file that uses this pattern, but I could, well, maybe I could make a script to do that?</p><p>Yeah, not so good.</p><p>There's some unpleasantness at work with the <em>dynamic_cast</em> - it breaks the abstraction pretty harsh, but with strongly typed variables, that sort of thing is, unless I come up with a better method of type inference, pretty inevitable. Worse is the hunk of convoluted code with no good means of reuse. There are a few appalling methods I could have used to try to tackle this - I briefly flirted with the idea of eldritch macros - but I found my way to a solution I think works pretty well.</p><p>C++ has, as one its pillars, the idea of <a href="http://en.wikipedia.org/wiki/Template_(programming">templates</a>), a method of defining functions and classes around generic objects, then specifying exactly what it is they work with when using them. Since they can be put to use with any sort of object, they're great for reusing the same code across different classes. Sounds a bit like what we were looking for with the component references - a way to encapsulate the casting logic to work with whatever type of component we might want to work with.</p><p>Let's take stock of the objectives once more just to be sure we have a clear idea of what it we're after. First and foremost, we need some way to reference specific types of components. To do this, we need to be able to determine types and use them as necessary. Second, whatever method we use, it should be suitable for any type of component and shouldn't require adding additional cases for new types. Third, it should be simple to use. I'm, as you'll recall, lazy. In this field, I assure myself, that's a good thing. Enter the <em>comp_ptr</em>.</p><p>In action, the <em>comp_ptr</em> is pretty much just a pointer to a component. However, it uses templating to specify the type of component it refers to. For instance, using this guy, a variable that refers to a <em>Spatial</em> component is defined as follows:</p><pre><code>comp_ptr&lt;Spatial&gt; spatial;</code></pre><p>So what? Well, assignment to a <em>comp_ptr</em> is done through a function which wraps up the type inference necessary to build a proper reference. It's a little inelegant right now, but the idea is there:</p><pre><code>void trySet( weak_ptr&lt;Component&gt; component ) {

	shared_ptr&lt;Component&gt; sComponent = component.lock();

	if ( sComponent ) {

		Component* rawComponent = sComponent.get();
		T* cast = dynamic_cast&lt;T*&gt;( rawComponent );

		if ( cast )
			ref = cast;
	}
}</code></pre><p>Sorry, I probably haven't worked out tabs in the code yet, so it'll be left-aligned. Uh, bear with me. You can see above where we check whether a particular component is of type T, where T is whatever type of component the <em>comp<i>ptr</i></em><i> has been defined with. All the magic happens inside this poorly-named function. From the outside, we just have to chuck in a component and let the <em>comp</em></i><em>ptr</em> figure it out. <em>Neat</em>. That's exactly what we were after! Problem solved and in less time than it took to type all this out.</p><p>There's a few things to sort out. Uh, using a raw pointer in there instead of a <em>weak<i>ptr</i></em><i> like we do elsewhere kind of sucks. There's a tremendous amount of overhead doing that <em>dynamic</em></i><em>cast</em> for every component. And right now, it's just ugly. Heck, we could maybe even overload the = operator to replace that unsightly <em>trySet</em> call. But still. I think this works.</p><p>Okay, well, that's a good deal more than enough of that. I've put far too many words into such a little thing, but I've never really made practical use of templating before and I had no idea it would work, let alone with so little hassle. I'm going to sleep on this before moving ahead because I feel there's a few issues some perspective could shine light on, but if this works, it's, well, dang, it's nice.</p></body></html></div><script type="text/javascript">hljs.highlightAll();</script></div></div></body></html>