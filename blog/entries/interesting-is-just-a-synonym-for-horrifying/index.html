<html><head><meta charset="utf-8" /><title>Interesting Is Just A Synonym For Horrifying</title><link href="/css/shades-of-purple.min.css" rel="stylesheet" /><link href="/css/common.css" rel="stylesheet" /><link href="/css/blog.css" rel="stylesheet" /><script src="/js/highlight.min.js" type="text/javascript"></script></head><body><div id="header"><h1><a href="/">Words in the Sky</a></h1><a href="/blog">Blog</a></div><div id="content"><div id="blog"><h1 class="title">Interesting Is Just A Synonym For Horrifying</h1><span class="date">Feb 15, 2012</span><div id="content"><html><head></head><body><p>The mileage you get out of this may well depend on how much of an OO purist you consider yourself.</p><p>You know it's gunna be a good one when we start like that.</p><h1 id="collision-collusion">Collision Collusion</h1><p>I've been trying to figure out what should happen when two object collide. Not the physics of it - good god, not the physics of it - but how they communicate with each other. Obviously, some kind of message passing needs to take place. If a being walks on fire, say, the fire needs to be able to tell the being that it's encountered some <a href="http://www.youtube.com/watch?v=eR_LsMzd6Hw">hot hot heat</a>. Taking some fire damage, maybe. However, since the entities are collections of generic components, there isn't a public-facing &quot;take fire damage&quot; method one entity might call on another. Instead, that method might be buried somewhere inside the entity if it has a health component. So, that gets us to a point where we need to get specific information to specific components. Okay, got your head around the problem? Let's do it.</p><p>There's kind of two ways to model this situation. Either the messages passed to an entity are pure data and the components pull them apart and act on them <em>or</em> the components are more data-y and the messages call methods on the components. I can't for the life of me figure out how to do the former, so by process of elimination, we're looking at the latter. A message interacts with a component by, effectively, bossing it around, albeit <em>appropriately</em>. The paragraph above outlined a decent example. Some kind of &quot;take fire damage message,&quot; when it finds a &quot;health component,&quot; tells it to take fire damage. Cool.</p><p>From there, we have to figure out how to get the message to a component, which takes us back to our friend <a href="http://wordsinthesky.com/blog/entries/on-the-subject-of-knock-knock-jokes">the visitor pattern</a>. Remember how well that went last time? Well, surely second time's the charm! Pop off a message/visitor to a component collection and let it figure out who it should be talking to. Sweet, good to go.</p><p>Except?</p><p>Well, here's the thing about the visitor pattern. It takes an absolute buttload of work to extend the class hierarchy because for every visitable element you add, you've got to give it an <code>accept</code> method <em>and</em> you've got to add a <code>visit</code> method to the visitors. Open/closed principle is off having a hissy fit over this. To mitigate the damage, you can get away with just adding NOOP methods to the base visitor class an overriding them as needed, but that's the second snarl - if one of these message visitors only visits one or two components, if feels like a big waste to load it up with visit methods for <em>every</em> dang type. It's just, it's gross. You've got to deal with the permutations of all combinations of visitors and components and that's unpleasant if for no other reason that it gloms all these different dimensions together, through thick and thin and recompile.</p><p>Okay. Now what?</p><h1 id="the-acyclic-picnic">The Acyclic Picnic</h1><p>Here's a thing called the <a href="http://www.google.ca/url?sa=t&amp;rct=j&amp;q=acyclic%20visitor&amp;source=web&amp;cd=1&amp;sqi=2&amp;ved=0CCIQFjAA&amp;url=http%3A%2F%2Fwww.objectmentor.com%2Fresources%2Farticles%2Facv.pdf&amp;ei=YCIvT5eIJ4HJiQKH0bHLCg&amp;usg=AFQjCNGMyoy2E1JAuc_3CHEZnsq_nS8H4Q">acyclic visitor</a>. I'd recommend reading the article, but let me see if I can describe it. On the visitor side of things, you've got some sort of general <code>AbstractVisitor</code>. Much like the regular visitor pattern, an <code>Element</code> has an <code>accept</code> method to receive the <code>AbstractVisitor</code> and again, this is implemented in derived classes so they can specify type information. However, instead of adding methods for every type of derived <code>Element</code> in the <code>AbstractVisitor</code>, a complimentary visitor class is created for each derived <code>Element</code> type - <code>DerivedElement</code> - with a method to visit it. Let's call this specialized visitor class, well, a <code>SpecializedVisitor</code>. To reiterate, the <code>SpecializedVisitor</code> implements <code>visit( DerivedElement* element )</code>.</p><p>Got that? The <code>AbstractVisitor</code> gets accepted. The <code>SpecializedVisitor</code> visits. The behaviour of the visitor has been broken into two entirely separate classes. Notice that neither one of these inherits from the other. Why?</p><p>Well, my imaginary friend, I'm glad you asked. Y'see, to create a complete, useful visitor class, the object must inherit from both the <code>AbstractVisitor</code> and the <code>SpecializedVisitor</code>. One parent gives it the ability to be accepted by an <code>Element</code>'s <code>accept</code> call. The other lets it visit that type of element. Let's call this guy a <code>ConcreteVisitor</code>.Okay, now here's the dicey bit: when a <code>DerivedElement</code> implements its <code>accept</code> method, it takes in the <code>AbstractVisitor</code> and then, through something like <code>dynamic_cast</code>, tries to cast the <code>AbstractVisitor</code> to a <code>SpecializedVisitor</code>. If the cast succeeds, ie, the types match, then the <code>DerivedElement</code> calls the <code>SpecializedVisitor</code>'s <code>visit</code> method. <em>Phew</em>.</p><p>The beauty of this of this is that it means that new types can be added without messing around with <em>any</em> of the existing classes. A <code>SpecializedVisitor</code> is only concerned with only the one <code>DerivedElement</code> it was written for. And hey, if you want to specialize a visitor for multiple types, well, just derive the <code>ConcreteVisitor</code> from multiple <code>SpecializedVisitors</code>. Each <code>DerivedElement</code> will try to cast the <code>ConcreteVisitor</code> to the type that matches itself.</p><p>We'll back up for a second and discuss the biggest wrinkle in the plan - the <code>dynamic_cast</code>. Bring up dynamic casting and you'll hear an uproar from two directions. OO dedicates will cringe from the perverted work against polymorphism while folks looking to crank every cycle out of the CPU will languish over the relative cost of using the function. As far as the first, well, it's not really a worry for me here. Dynamic casts are monstrous when used in conjunction with a huge nest of if-statements, but in this case, it does more to keep classes sealed than not. With the second, it's a legitimate concern, but at this point, without much context for what it'll eat in the way resources when everything's up and running, I'm not going to sweat it. Whoo!</p><h1 id="template-my-typecast-capn">Template My Typecast, Cap'n</h1><p>By no means have I committed to this technique. We're defs in the planning stages here. However, today I wrote up some code implementing the ideas above to see how it felt. Wanna give it a look?</p><pre><code>// declaration of visitor type
class AbstractComponentVisitor {
public:
	// every object needs at least one method?
	virtual ~AbstractComponentVisitor() {}
};</code></pre><p>The <code>AbstractComponentVisitor</code> is boring as porridge. Movin' on.</p><pre><code>// the top level component
class GenericComponent {
public:
	virtual void accept( AbstractComponentVisitor* visitor ) {
		// noop
	}
};</code></pre><p>The GenericComponent sits at the top of the component hierarchy. It doesn't do jack squat with the visitor, but whether that's the best way to handle this case is a straight up guess. However, implementing this method means that components which never meant nothing to nobody don't have to supply an <code>accept</code> method. It's a nice fallback, anyway. Okay, things are going to get choppier.</p><p>Examining the acyclic visitor, you can see that though the visitor specializations act on different classes, the pattern of operation is the same. Abstracting the algorithm from the types involved? Well gang, looks like we're talking C++ templates. We'll start with the visitor itself - ideally, we can use templates to create the different specializations. Shouldn't be too hard.</p><pre><code>// a specialized visitor class
template&lt;typename COMPONENT_TYPE&gt;
class ComponentVisitor {
public:
	virtual void visit( COMPONENT_TYPE* component ) = 0;
};</code></pre><p>Hey, neat! So, a concrete visitor inherits from a <code>ComponentVisitor</code> specialized to a type of component. That's simple enough. Now my hardheadedness wants to hide away the implementation of this visitor method stuff as much as possible. That is, I'd rather not have to worry about writing out the <code>accept</code> method for each visitable component. Templates, again, are going to to be used here, but it's a little hackey - er, unorthodox. We'll get the code out of the way first:</p><pre><code>// the actual visitable component
template&lt;typename COMPONENT_TYPE&gt;
class VisitableComponent : public GenericComponent {
public:
	void accept( AbstractComponentVisitor* abstractVisitor ) {

		// pull out the visitor type		
		typedef ComponentVisitor&lt;COMPONENT_TYPE&gt; TypeVisitor;
		TypeVisitor* visitor;
		visitor = dynamic_cast&lt;TypeVisitor*&gt;( abstractVisitor );

		// if types match, visit
		if ( visitor ) {

			// downcast to the actual component type
			COMPONENT_TYPE* realThis
				= static_cast&lt;COMPONENT_TYPE*&gt;( this );

			visitor-&gt;visit( realThis );
		}		

		// otherwise, handle mismatch
		else {

			// noop?
		}
	}
};</code></pre><p>Okay, by and large that looks like what you'd expect. It accepts a visitor and does the cross-cast. But what's up with the downcasting? Well, the only way to add stuff to a template class, as we covered before, is either specializing it or subclassing it. Specialization isn't an option here - we're talking a greatly varied collection of components and cramming them closer together isn't going to work. Instead, we'll take the inheritance route. The <code>VisitableComponent</code> sits in between a derived component and the <code>GenericComponent</code> at the root of the tree. Squirrelled away in that niche, it adds all the visitor stuff to the subsequently derived class. The downcast just takes us from this more-or-less useless class to the actual derived one. Trendy.</p><p>The hell of it is that for this to work, the derived component must use <em>itself</em> as the template parameter for the super class. It's a bizzarre syntax that looks like this:</p><pre><code>class SomeComponent : public VisitableComponent&lt;SomeComponent&gt;</code></pre><p>This bugged me enough to write a couple of macros that add more context to what's happening.</p><pre><code>#define DECLARE_VISITABLE_COMPONENT(component_type) \
	public VisitableComponent&lt;component_type&gt;

#define REGISTER_COMPONENT_VISITOR(component_type) \
	public ComponentVisitor&lt;component_type&gt;</code></pre><p>With these fellas, the class definitions look more like this:</p><pre><code>class SomeComponent : DECLARE_VISITABLE_COMPONENT(SomeComponent)

class SomeComponentVisitor : public AbstractComponentVisitor
	, REGISTER_COMPONENT_VISITOR(SomeComponent)</code></pre><p>You can take or leave the syntactic sugar of the macro. It's weird, but I think the added information makes the intent of the code much clearer. It's strange though. <a href="/blog/entries/acyclic-visitor-messages.cpp">But it works!</a></p><p>Mostly. There's a few qualms to be had, certainly, perhaps the worst of which is only one class in a branch can be registered as visitable. That is, if a <code>DrawShape</code> class is made visitable, the further derived <code>DrawSquare</code> can't be. Of course, the same is true of the basic visitor pattern.</p><p>Like I said, I haven't committed to this ploy, but it's a neat idea regardless. Everything aside, I like the ease of use. Inheirit and go, just that simple. I've had a few other ideas, but none quite so straightforward in the result. That, above all else, is my main goal. One of the guiding quotes of my software career is <a href="http://www.goodreads.com/quotes/show/44564">this one</a> by Oliver Wendell Holmes Sr. Whatever hell it takes getting this in, I want it to be simple coming out.</p></body></html></div><script type="text/javascript">hljs.highlightAll();</script></div></div></body></html>