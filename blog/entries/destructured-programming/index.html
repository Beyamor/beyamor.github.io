<html><head><meta charset="utf-8" /><title>Destructured Programming</title><link href="/css/shades-of-purple.min.css" rel="stylesheet" /><link href="/css/common.css" rel="stylesheet" /><link href="/css/blog.css" rel="stylesheet" /><script src="/js/highlight.min.js" type="text/javascript"></script></head><body><div id="header"><h1><a href="/">Words in the Sky</a></h1><a href="/blog">Blog</a></div><div id="content"><div id="blog"><h1 class="title">Destructured Programming</h1><h2 class="date">Dec 13, 2012</h2><div id="content"><html><head></head><body><p>Hey kids, you want to see something neat? Here, hold my beer.</p><h1>I Structure, U Structure, We Structure, De Structure</h1><p>Okay. So, bit of preamble here. Like a lot of nice languages, Clojure supports destructuring. Destructuring is a fancy term for taking apart some value and grabbing the pieces you're interested in. So, like, if someone handed you some trail mix, you'd destructure that to pull out the M&amp;M's because c'mon, who wants the rest of that?</p><p>Some preamble for the preamble then.</p><h1>Stick It In Some Gull Wings</h1><p>We've talked about this before, but in Clojure, a map looks like this:</p><pre><code>{:a 1
 :b 2}</code></pre><p>Here the key <code>:a</code> has the value <code>1</code> and the key <code>:b</code> has the value <code>2</code>. Right?</p><h1>Break It Down</h1><p>Now, we can destructure a map to pull out the values.</p><pre><code>(let [{a :a, b :b} {:a 1, :b 2}]
 (+ a b))</code></pre><p>So, we're pulling out the values for the keys <code>:a</code> and <code>:b</code> and binding them to <code>a</code> and <code>b</code> so we can use them. We're taking apart the map to grab the values we're interested in.</p><p>We don't have to bind <code>:a</code> and <code>:b</code> to <code>a</code> and <code>b</code>. We could just as easily write the destructuring like this:</p><pre><code>(let [{bus :a, kitty :b} {:a 1, :b 2}]
 (+ bus kitty))</code></pre><p>However, chances are good that you'll want to bind keywords to symbols of the same name. Clojure even offers some special syntactic sugar to cover this.</p><pre><code>(let [{:keys [a b]} {:a 1, :b 2}]
 (+ a b))</code></pre><h1>Infer This</h1><p>Sweet. That's some hella good preamble there. Now, what are we going to do with it?</p><p>So, okay. A function is a thing. A really boring function that increases whatever you give it by one might look like this:</p><pre><code>(fn [x] (inc x))</code></pre><p>With me so far?</p><p>Now, at the moment, I've got this idea in my meat-potato brain where I might have a bunch of functions in a list and I want to go through and pass each of them the same map of data. The thing I'm kicking around in my head is a bit of game architecture, so this map of data might contain stuff like a list of entities, the graphics context, and the input state.</p><p>Not all of the functions are going to use all of the data. Some are just going to want to look at the entities, while some are going to want to look at the entities and the graphics context.</p><p>Given our friend destructuring up there, I might end up with some functions like this:</p><pre><code>(fn [{:keys [entities]}] (do-some-entity-thing entities))

(fn [{:keys [entities graphics]}] (draw-some-entities entity graphics))</code></pre><p>But this is kind of suck, right? Because all of these functions will take the exact same argument, that blob of data, and then, in all likelihood, they'll destructure it in some way. And I'm lazy, right? I don't want to have to write out that destructuring step every time. That's a lot of hassle. In an ideal world, all I'd have to write is this:</p><pre><code>(fn [entities] (do-some-entity-thing entities))

(fn [entities graphics] (draw-some-entities entity graphics))</code></pre><p>And then, y'know, <em>something</em> figures out the destructuring step for us. Some magic process looks at the arguments the function needs and is smart enough to pull them out of the data blob.</p><p>So the problem's nice here because it's well-structured and regular. It's so simple we could even probably tell a computer how to do it. I mean - hey, actually, why don't we do that? Let's get the computer to do it!</p><h1>Wait What</h1><p>Before going ahead, I want to make sure we're on the same page. What we want to be able to do is write functions that require the data blob to be destructured and its values passed on, but we don't want to have to write the destructuring ourselves. We just want to declare the arguments the function needs and let the system figure out the intermediate destructuring step.</p><p>It's not totally superficial either. What we're doing, by boiling the function definition down to only the argument it expects, we're making the intention clearer and separating the structure of the function from the context in which it might be used. This is good stuff.</p><h1>Meta Cheese</h1><p>Okay. An important piece going ahead is Clojure's <a href="http://clojure.org/metadata">metadata</a> system. This lets you attach arbitrary information to something. It doesn't change the value or how it operates in the system, but it's something you can hook onto for, well, whatever.</p><p>So that sounds good, eh?</p><p>We've actually got a nice case for metadata here. The functions we're defining should behave like functions, y'know? At the end of the day, you call them and values come out. However, we want to be able to inspect the functions to examine their arguments. If we can do that, then we can start on the actual destructuring layer.</p><p>With that established, what we're going to do is attach the list of a function's arguments to the function as metadata. Like, the actual names of the arguments. Here, look at this:</p><pre><code>(with-meta
 (fn [x] (inc x))
 {:arg-list [:x]})</code></pre><p>Okay? So, with the function that takes <code>x</code> and increments it, we have an <code>arg-list</code> that says the function takes a single argument, <code>:x</code>. We're using the keyword <code>:x</code> just because it's easier to write, but it'll work out the same. The point is, we've now just attached the function's argument list to it as metadata. Cool!</p><p>Obviously this is a bit of a mouthful. We don't want to have to write all that every time we make a function. Luckily, it's pretty easy to write a macro to handle this:</p><pre><code>(defmacro fn|arg-list
 [args &amp; body]
 (let [arg-list (vec (map keyword args))]
  `(with-meta
    (fn ~args ~@body)
    {:arg-list ~arg-list})))</code></pre><p>This macro just does the junk we wrote by hand up above. Check it:</p><pre><code>(fn|arg-list [x] (inc x))</code></pre><p>This'll create the incrementing function and attach the arg-list <code>[:x]</code> to it as metadata. Hella hip!</p><h1>One Warped Wrap</h1><p>Let me be blunt: this next bit is the butts hardest part of this. We get into dynamic, run-time function generation. Shit be mad whack.</p><p>Working from the other end, given a list of arguments, we want to create a wrapper function which, when called with another function and a data blob, destructures the data blob and feeds the values to the function.</p><p>What.</p><p>Okay, hang on. We're looking for something like this:</p><pre><code>((make-wrapper-fn ['x])
  (fn [x] (inc x))
  {:x 1}))</code></pre><p><code>make-wrapper-fn</code> produces a wrapper function which destructures a blob to pull out <code>x</code>. When we feed the wrapper function the increment function and the data blob, it destructures the data blob and calls the increment function with <code>x</code>.</p><p>Whew. How're you holding up?</p><p>The code for <code>make-wrapper-fn</code> is actually insultingly simple.</p><pre><code>(defn make-wrapper-fn
 [symbolic-arg-list]
 (eval
  `(fn [f# {:keys ~symbolic-arg-list}]
    (f# ~@symbolic-arg-list))))</code></pre><p>Right? Pretty much what you would expect. The resulting function takes two arguments, the function <code>f#</code> and the data blob. The data blob is then destructured using the argument list <code>symbolic-arg-list</code>. Then, with the argument values bound, <code>f#</code> is called with its argument list.</p><p>And, well, we have to <code>eval</code> the whole thing into existence because this is black magic, but it's fuckin' rad, so whatever.</p><h1>Wrap It Harder Make It Better</h1><p>Now we can more or less put the two big pieces together. Here's a function, <code>inference-wrapper</code>. You pass it a function. If the function includes the <code>arg-list</code> metadata, it gets wrapped in a destructuring function. Otherwise, the function is returned as normal.</p><pre><code>(defn inference-wrapper
 [f]
 (if-let [arg-list (-?&gt; f meta :arg-list)]
  (let [symbolic-arg-list (vec (map #(-&gt; % name symbol) arg-list))]
   (partial
    (make-wrapper-fn symbolic-arg-list)
    f))
  f))</code></pre><p>Make sense? If we've got the metadata, build the wrapper function and partially apply it with <code>f</code> so that's it's ready to accept the data blob. Otherwise, assume the function is willing to handle the whole data blob, so just return it. We can call this function like so:</p><pre><code>((inference-wrapper
  (fn|arg-list [x] (inc x)))
 {:x 1})</code></pre><p>Or, if the metadata isn't supplied:</p><pre><code>((inference-wrapper
  (fn [{x :x}] (inc x)))
 {:x 1})</code></pre><p>Neat.</p><h1>And Then The Computer Does It</h1><p>So, I mean, that's it. That's all it takes. With a macro that can infer the argument list metadata and a function that can create a destructuring wrapper for an argument list, we've got it all.</p><p>The cool thing about this is how easy it was. Actually writing the code took no time at all. Trying to explain it took, like, half the night. Such is the nature of macros, right?</p><p>Still, it's pretty hip. This scheme makes it possible to define clean, simple functions which are simple to read and use, but retains the argument processing required so that everything can be homogeneously supplied with the same data blob. The real win here is that the functions are decoupled from the context in which they're used. How smart is that?</p><p>Check out the full code <a href="https://gist.github.com/4283258">here</a> and some tests <a href="https://gist.github.com/4283264">here</a>.</p></body></html></div><script type="text/javascript">hljs.highlightAll();</script></div></div></body></html>